<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Heart</title>

    <style>
      html,
      body {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        overflow: hidden;
      }

      canvas#pinkboard {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .center-text {
        color: #00ffff;
        font-size: 32px;
        font-style: italic;
        text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        margin-top: 550px;
        z-index: 2;
        animation: glow 2s ease-in-out infinite alternate;
      }

      @keyframes glow {
        from {
          text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        }

        to {
          text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
        }
      }
      @keyframes rainbow-glow {
        0% {
          text-shadow: 0 0 10px red, 0 0 20px red;
          color: red;
        }
        14% {
          text-shadow: 0 0 10px orange, 0 0 20px orange;
          color: orange;
        }
        28% {
          text-shadow: 0 0 10px yellow, 0 0 20px yellow;
          color: yellow;
        }
        42% {
          text-shadow: 0 0 10px limegreen, 0 0 20px limegreen;
          color: limegreen;
        }
        57% {
          text-shadow: 0 0 10px blue, 0 0 20px blue;
          color: blue;
        }
        71% {
          text-shadow: 0 0 10px indigo, 0 0 20px indigo;
          color: indigo;
        }
        85% {
          text-shadow: 0 0 10px violet, 0 0 20px violet;
          color: violet;
        }
        100% {
          text-shadow: 0 0 10px red, 0 0 20px red;
          color: red;
        }
      }

      /* Class mới để áp dụng hiệu ứng rainbow-glow */
      .rainbow-active {
        /* Quan trọng: Hiệu ứng này sẽ ghi đè hiệu ứng 'glow' màu xanh mặc định */
        animation: rainbow-glow 3s linear infinite;
      }
      #stars {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
      }
      @media (max-width: 600px) {
        /* Tăng kích thước chữ hiển thị ban đầu */
        .center-text {
          font-size: 32px; /* Tăng từ 32px lên 40px */
          /* Có thể điều chỉnh lại margin-top nếu cần */
          margin-top: 500px;
        }
      }
    </style>
  </head>

  <body>
    <canvas id="stars"></canvas>
    <canvas id="pinkboard"></canvas>

    <div class="center-text" id="introText">Ấn vào màn hình</div>
    <audio id="backgroundMusic" loop autoplay>
      <source src="nhac.mp3" type="audio/mpeg" />
      Trình duyệt của bạn không hỗ trợ phần tử audio.
    </audio>
    <script>
      const starCanvas = document.getElementById("stars");
      const starCtx = starCanvas.getContext("2d");
      let stars = [];

      function initStars() {
        starCanvas.width = window.innerWidth;
        starCanvas.height = window.innerHeight;
        stars = [];
        for (let i = 0; i < 200; i++) {
          stars.push({
            x: Math.random() * starCanvas.width,
            y: Math.random() * starCanvas.height,
            r: Math.random() * 2,
            alpha: Math.random(),
            dAlpha: Math.random() * 0.02 + 0.005,
          });
        }
      }

      function drawStars() {
        starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
        starCtx.fillStyle = "#00ffff";
        for (let star of stars) {
          starCtx.globalAlpha = star.alpha;
          starCtx.beginPath();
          starCtx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          starCtx.fill();
          star.alpha += star.dAlpha;
          if (star.alpha <= 0 || star.alpha >= 1) star.dAlpha = -star.dAlpha;
        }
        requestAnimationFrame(drawStars);
      }

      window.addEventListener("resize", initStars);
      initStars();
      drawStars();

      var settings = {
        particles: {
          length: 1000,
          duration: 2,
          velocity: 100,
          effect: -1.3,
          size: 13,
        },
        largeFloatingImages: {
          count: 10,
          minSize: 120,
          maxSize: 180,
          rotationSpeed: 1,
          pulseSpeed: 3,
          fadeDuration: 5,
          travelDistance: 200,
        },
      };

      var Point = function (x, y) {
        this.x = x || 0;
        this.y = y || 0;
      };
      Point.prototype.clone = function () {
        return new Point(this.x, this.y);
      };
      Point.prototype.length = function (l) {
        if (typeof l === "undefined")
          return Math.sqrt(this.x * this.x + this.y * this.y);
        this.normalize();
        this.x *= l;
        this.y *= l;
        return this;
      };
      Point.prototype.normalize = function () {
        var l = this.length();
        this.x /= l;
        this.y /= l;
        return this;
      };

      var Particle = function () {
        this.position = new Point();
        this.velocity = new Point();
        this.acceleration = new Point();
        this.age = 0;
      };
      Particle.prototype.initialize = function (x, y, dx, dy) {
        this.position.x = x;
        this.position.y = y;
        this.velocity.x = dx;
        this.velocity.y = dy;
        this.acceleration.x = dx * settings.particles.effect;
        this.acceleration.y = dy * settings.particles.effect;
        this.age = 0;
      };
      Particle.prototype.update = function (dt) {
        this.position.x += this.velocity.x * dt;
        this.position.y += this.velocity.y * dt;
        this.velocity.x += this.acceleration.x * dt;
        this.velocity.y += this.acceleration.y * dt;
        this.age += dt;
      };
      Particle.prototype.draw = function (ctx, img) {
        function ease(t) {
          return -t * t * t + 1;
        }
        var ageRatio = this.age / settings.particles.duration;
        var size = img.width * ease(ageRatio);
        ctx.globalAlpha = 1 - ageRatio;
        ctx.drawImage(
          img,
          this.position.x - size / 2,
          this.position.y - size / 2,
          size,
          size
        );
      };

      var ParticlePool = function (length) {
        var particles = new Array(length),
          firstActive = 0,
          firstFree = 0,
          duration = settings.particles.duration;
        for (var i = 0; i < particles.length; i++)
          particles[i] = new Particle();
        this.add = function (x, y, dx, dy) {
          particles[firstFree].initialize(x, y, dx, dy);
          firstFree++;
          if (firstFree == particles.length) firstFree = 0;
          if (firstActive == firstFree) {
            firstActive++;
            if (firstActive == particles.length) firstActive = 0;
          }
        };
        this.update = function (dt) {
          var i;
          if (firstActive < firstFree) {
            for (i = firstActive; i < firstFree; i++) particles[i].update(dt);
          }
          if (firstFree < firstActive) {
            for (i = firstActive; i < particles.length; i++)
              particles[i].update(dt);
            for (i = 0; i < firstFree; i++) particles[i].update(dt);
          }
          while (
            particles[firstActive].age >= duration &&
            firstActive != firstFree
          ) {
            firstActive++;
            if (firstActive == particles.length) firstActive = 0;
          }
        };
        this.draw = function (ctx, img) {
          var i;
          if (firstActive < firstFree) {
            for (i = firstActive; i < firstFree; i++)
              particles[i].draw(ctx, img);
          }
          if (firstFree < firstActive) {
            for (i = firstActive; i < particles.length; i++)
              particles[i].draw(ctx, img);
            for (i = 0; i < firstFree; i++) particles[i].draw(ctx, img);
          }
        };
      };

      (function (canvas) {
        var ctx = canvas.getContext("2d"),
          particles = new ParticlePool(settings.particles.length),
          particleRate =
            settings.particles.length / settings.particles.duration,
          time;

        var particleTimeAccumulator = 0;
        var idealParticleDelta = 1 / particleRate;

        function pointOnHeart(t) {
          return new Point(
            160 * Math.pow(Math.sin(t), 3),
            130 * Math.cos(t) -
              50 * Math.cos(2 * t) -
              20 * Math.cos(3 * t) -
              10 * Math.cos(4 * t) +
              25
          );
        }

        const smallHearts = [];
        const minDistance = 250;
        const maxRange = 800;

        function randomPosition() {
          let x, y;
          do {
            x = (Math.random() * 2 - 1) * maxRange;
            y = (Math.random() * 2 - 1) * maxRange;
          } while (Math.sqrt(x * x + y * y) < minDistance);
          return {
            x,
            y,
          };
        }

        for (let i = 0; i < 20; i++) {
          let pos = randomPosition();
          smallHearts.push({
            x: pos.x,
            y: pos.y,
            scale: 0.1 + Math.random() * 0.2,
            phase: Math.random() * Math.PI * 2,
            life: 0,
            duration: 200 + Math.random() * 200,
            pool: new ParticlePool(50),
            accumulator: 0,
            rate: 50 / settings.particles.duration,
          });
        }

        var largeFloatingImages = [];
        var largeImageSrc = "cheem.png";
        var largeFloatingImage = new Image();

        var rotationSpeed = 2;
        var centerImage = new Image();

        let imagesLoadedCount = 0;
        const totalImagesToLoad = 2;

        function startRenderLoop() {
          imagesLoadedCount++;
          if (imagesLoadedCount === totalImagesToLoad) {
            window.onresize = onResize;
            onResize();
            render();
          }
        }
        const music = document.getElementById("backgroundMusic");
        if (music) {
          music.play().catch((error) => {
            console.warn(
              "Lỗi: Tự động phát bị chặn. Vui lòng nhấp vào màn hình."
            );
          });
        }

        largeFloatingImage.onload = startRenderLoop;
        largeFloatingImage.src = largeImageSrc;

        centerImage.onload = startRenderLoop;
        centerImage.src = "image.jpg";

        function initLargeFloatingImages() {
          largeFloatingImages = [];
          for (let i = 0; i < settings.largeFloatingImages.count; i++) {
            let pos = randomPosition();
            largeFloatingImages.push({
              x: pos.x,
              y: pos.y,
              size:
                settings.largeFloatingImages.minSize +
                Math.random() *
                  (settings.largeFloatingImages.maxSize -
                    settings.largeFloatingImages.minSize),
              rotationOffset: Math.random() * Math.PI * 2,
              pulseOffset: Math.random() * Math.PI * 2,
              fadeInTime: 0,
              fadeOutTime: settings.largeFloatingImages.fadeDuration,
              lifeTime: 0,
              maxLifeTime: 10 + Math.random() * 10,
              travelDirection: {
                x: Math.random() * 2 - 1,
                y: Math.random() * 2 - 1,
              },
              originX: pos.x,
              originY: pos.y,
            });
          }
        }

        var image = (function () {
          var c = document.createElement("canvas"),
            ctx = c.getContext("2d");
          c.width = settings.particles.size;
          c.height = settings.particles.size;

          function to(t) {
            var p = pointOnHeart(t);
            p.x =
              settings.particles.size / 2 +
              (p.x * settings.particles.size) / 350;
            p.y =
              settings.particles.size / 2 -
              (p.y * settings.particles.size) / 350;
            return p;
          }
          ctx.beginPath();
          var t = -Math.PI,
            p = to(t);
          ctx.moveTo(p.x, p.y);
          while (t < Math.PI) {
            t += 0.01;
            p = to(t);
            ctx.lineTo(p.x, p.y);
          }
          ctx.closePath();
          ctx.fillStyle = "#00FFFF";
          ctx.fill();
          var img = new Image();
          img.src = c.toDataURL();
          return img;
        })();
        var smallImage = (function () {
          var c = document.createElement("canvas"),
            ctx = c.getContext("2d");

          c.width = settings.particles.size / 2;
          c.height = settings.particles.size / 2;

          function to(t) {
            var p = pointOnHeart(t);
            p.x = c.width / 2 + (p.x * c.width) / 350;
            p.y = c.height / 2 - (p.y * c.height) / 350;
            return p;
          }
          ctx.beginPath();
          var t = -Math.PI,
            p = to(t);
          ctx.moveTo(p.x, p.y);
          while (t < Math.PI) {
            t += 0.01;
            p = to(t);
            ctx.lineTo(p.x, p.y);
          }
          ctx.closePath();
          ctx.fillStyle = "#00FFFF";
          ctx.fill();
          var img = new Image();
          img.src = c.toDataURL();
          return img;
        })();

        function render() {
          requestAnimationFrame(render);
          var newTime = new Date().getTime() / 1000,
            dt = newTime - (time || newTime);

          dt = Math.min(dt, 1 / 30);
          time = newTime;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          particleTimeAccumulator += dt;
          while (particleTimeAccumulator >= idealParticleDelta) {
            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
            var dir = pos.clone().length(settings.particles.velocity);
            particles.add(
              canvas.width / 2 + pos.x,
              canvas.height / 2 - pos.y,
              dir.x,
              -dir.y
            );
            particleTimeAccumulator -= idealParticleDelta;
          }

          particles.update(dt);
          ctx.save();
          ctx.globalAlpha = 1;
          particles.draw(ctx, image);
          ctx.restore();

          smallHearts.forEach((h) => {
            h.life++;
            if (h.life > h.duration) {
              let pos = randomPosition();
              h.x = pos.x;
              h.y = pos.y;
              h.life = 0;
              h.duration = 200 + Math.random() * 200;
            }

            var idealSmallParticleDelta = 1 / h.rate;
            h.accumulator += dt;
            while (h.accumulator >= idealSmallParticleDelta) {
              var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
              var dir = pos.clone().length(settings.particles.velocity * 0.3);
              h.pool.add(
                canvas.width / 2 + h.x + pos.x * h.scale,
                canvas.height / 2 + h.y - pos.y * h.scale,
                dir.x,
                -dir.y
              );
              h.accumulator -= idealSmallParticleDelta;
            }

            h.pool.update(dt);

            ctx.save();
            ctx.globalAlpha = 0.8;
            h.pool.draw(ctx, smallImage);
            ctx.restore();
          });

          largeFloatingImages.forEach((lfi, index) => {
            lfi.lifeTime += dt;

            let currentAlpha;
            const fadeDuration = settings.largeFloatingImages.fadeDuration;
            if (lfi.lifeTime < fadeDuration) {
              currentAlpha = lfi.lifeTime / fadeDuration;
            } else if (lfi.lifeTime > lfi.maxLifeTime - fadeDuration) {
              currentAlpha = (lfi.maxLifeTime - lfi.lifeTime) / fadeDuration;
            } else {
              currentAlpha = 1;
            }
            currentAlpha = Math.max(0, Math.min(1, currentAlpha));

            if (lfi.lifeTime > lfi.maxLifeTime) {
              let pos = randomPosition();
              Object.assign(lfi, {
                x: pos.x,
                y: pos.y,
                size:
                  settings.largeFloatingImages.minSize +
                  Math.random() *
                    (settings.largeFloatingImages.maxSize -
                      settings.largeFloatingImages.minSize),
                rotationOffset: Math.random() * Math.PI * 2,
                pulseOffset: Math.random() * Math.PI * 2,
                lifeTime: 0,
                maxLifeTime: 10 + Math.random() * 10,
                travelDirection: {
                  x: Math.random() * 2 - 1,
                  y: Math.random() * 2 - 1,
                },
                originX: pos.x,
                originY: pos.y,
              });
            }

            const travelFactor =
              Math.sin(lfi.lifeTime * 0.5) *
              settings.largeFloatingImages.travelDistance;
            const currentX = lfi.originX + lfi.travelDirection.x * travelFactor;
            const currentY = lfi.originY + lfi.travelDirection.y * travelFactor;

            ctx.save();
            ctx.translate(
              canvas.width / 2 + currentX,
              canvas.height / 2 + currentY
            );

            const rot =
              newTime * settings.largeFloatingImages.rotationSpeed +
              lfi.rotationOffset;
            const scaleX = Math.cos(rot);
            ctx.scale(scaleX, 1);

            const pulse =
              1 +
              0.2 *
                Math.sin(
                  newTime * settings.largeFloatingImages.pulseSpeed +
                    lfi.pulseOffset
                );
            const imgWidth = lfi.size * pulse;
            const imgHeight = lfi.size * pulse;

            ctx.globalAlpha = currentAlpha * 0.9;
            ctx.drawImage(
              largeFloatingImage,
              -imgWidth / 2,
              -imgHeight / 2,
              imgWidth,
              imgHeight
            );
            ctx.restore();
          });

          var t = (new Date().getTime() / 1000) * rotationSpeed;
          var scaleX = Math.cos(t);
          var pulse = 1 + 0.2 * Math.sin(newTime * 5);
          var imgWidth = 80 * pulse;
          var imgHeight = 80 * pulse;

          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.scale(scaleX, 1);
          ctx.globalAlpha = 0.9;
          ctx.drawImage(
            centerImage,
            -imgWidth / 2,
            -imgHeight / 2,
            imgWidth,
            imgHeight
          );
          ctx.restore();
        }

        function onResize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          initLargeFloatingImages();
        }
      })(document.getElementById("pinkboard"));

      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      const music = document.getElementById("backgroundMusic");
      const introText = document.getElementById("introText");
      const body = document.body;

      let colorInterval;
      document.addEventListener(
        "click",
        function () {
          introText.innerHTML = "Cắc Cùm Cum Cắc Cùm Cum :3";
          introText.classList.add("rainbow-active");

          colorInterval = setInterval(() => {
            body.style.backgroundColor = getRandomColor();
          }, 150);
          if (music.paused) {
            music.play().catch((error) => {
              console.log(
                "Autoplay bị chặn, cần thêm tương tác của người dùng."
              );
            });
          }
        },
        { once: true }
      );
    </script>
  </body>
</html>
